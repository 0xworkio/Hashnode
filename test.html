<p>
  In my journey as a developer, I've often found myself grappling with data
  validation in Node.js. While there are numerous libraries and techniques
  available, I always seemed to be making minor adjustments here and there to
  get things just right. That was until I discovered a function that not only
  streamlined the process but also leveraged TypeScript's static typing for
  enhanced safety and predictability. Today, I'm excited to share this function
  that has become a staple in all my projects.
</p>
<h2>The Power of Zod</h2>
<p>
  <a target="_blank" href="https://zod.dev/">Zod</a> is a powerful tool for
  creating schemas and validating data. It's built with TypeScript in mind,
  meaning it has excellent TypeScript support out of the box. This makes it a
  great choice for TypeScript projects where you want to leverage the power of
  static typing to catch errors early.
</p>
<h2>he Magic Function</h2>
<p>
  First, let's install Zod. I will be using
  <a target="_blank" href="https://pnpm.io/">pnpm</a>, but you can use whatever
  package manager you want.
</p>
<div>
  <div>
    <div>
      <pre><code class="lang-bash">pnpm add zod
  </code></pre>
    </div>
  </div>
  <p>
    Below is the function I've been using for every one of my projects for quite
    a while now, taking advantage of a few cool features I'll explain in greater
    detail right after! I recommend placing it in a <code>utils</code> folder or
    file.
  </p>
  <div>
    <div>
      <div>
        <div>
          <pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { ZodObject, ZodRawShape, z } <span class="hljs-keyword">from</span> <span class="hljs-string">"zod"</span>;
  
  <span class="hljs-comment">/**
   * Get and validate data provided in the request body of a backend route.
   *
   * @param req The Request object.
   * @param schema The Zod Schema to validate the data against.
   * @returns Promise resolving to the data if successful, or an error if not.
   */</span>
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAndValidateRequestData</span>&lt;
    <span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">ZodObject</span>&lt;<span class="hljs-title">ZodRawShape</span>&gt;
  &gt;(<span class="hljs-params">
    request: Request,
    requestSchema: T
  </span>): /* <span class="hljs-title">The</span> <span class="hljs-title">following</span> <span class="hljs-title">return</span> <span class="hljs-title">type</span> <span class="hljs-title">enables</span> <span class="hljs-title">TypeScript</span> <span class="hljs-title">to</span> <span class="hljs-title">show</span> <span class="hljs-title">data</span> <span class="hljs-title">or</span> <span class="hljs-title">error</span> <span class="hljs-title">as</span> <span class="hljs-title">defined</span>,
  <span class="hljs-title">by</span> <span class="hljs-title">checking</span> <span class="hljs-title">for</span> <span class="hljs-title">an</span> <span class="hljs-title">undefined</span> <span class="hljs-title">value</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">other</span> <span class="hljs-title">property</span>. */
  <span class="hljs-title">Promise</span>&lt;</span>{ data: z.infer&lt;T&gt;; error: <span class="hljs-literal">undefined</span> } | { data: <span class="hljs-literal">undefined</span>; error: <span class="hljs-built_in">Error</span> }&gt; {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> request.json();
  
      <span class="hljs-comment">/* Validate the data with zod. Not using requestSchema.safeParse(),
      since request.json() could throw an error as well. */</span>
      requestSchema.parse(data);
  
      <span class="hljs-keyword">return</span> { data, error: <span class="hljs-literal">undefined</span> };
    } <span class="hljs-keyword">catch</span> (error: <span class="hljs-built_in">any</span>) {
      <span class="hljs-keyword">return</span> { data: <span class="hljs-literal">undefined</span>, error };
    }
  }
  </code></pre>
        </div>
      </div>
    </div>
    <h2 id="heading-leveraging-typescript-generics" class="permalink-heading">
      <strong>Leveraging TypeScript Generics</strong>
    </h2>
    <p>
      The function utilizes
      <a
        target="_blank"
        href="https://www.typescriptlang.org/docs/handbook/2/generics.html"
        >TypeScript Generics</a
      >, specifically <code>T extends ZodObject&lt;ZodRawShape&gt;</code>. This
      <code>T</code> represents the Zod schema that we pass to the function. By
      using this generictype <code>T</code>, we're able to infer the type of the
      data that the function returns. This means that the data returned by the
      function will automatically match the Zod schema passed to the function,
      providing us with type safety and auto-completion in our IDEs. This is a
      powerful feature that enhances the robustness and reliability of our data
      validation process.
    </p>
    <h2 id="heading-why-this-return-type" class="permalink-heading">
      Why This Return Type?
    </h2>
    <p>You might wonder why I'm using this particular return type:</p>

    <p>instead of for example this one:</p>

    <p>
      The reason is that it provides a very useful benefit in TypeScript. While
      the data and error returned from the function can initially both be
      undefined, the data will show as defined after checking for an error and
      vice versa. This is not the case with alternative syntaxes where data and
      error will always show up as possibly undefined.
    </p>
    <h2>Why Not Use safeParse?</h2>
    <p>
      Another question you might have when you've already used Zod in other
      projects is why I'm using <code>schema.parse</code> with a try-catch block
      instead of just using <code>schema.safeParse</code>. The reason is that
      <code>req.json()</code> could throw an error as well that would not be
      caught if I were just using <code>safeParse</code>.
    </p>
    <h2>Usage</h2>
    <p>
      I typically export the function from a utils folder and use it in my
      backend routes. Here's an example of how you might use it in a
      <a
        target="_blank"
        href="https://nextjs.org/docs/app/building-your-application/routing/router-handlers"
        >Next.js 13 API route</a
      >:
    </p>
    <pre><code class="lang-typescript"><span class="hljs-keyword">import</span> { z } <span class="hljs-keyword">from</span> <span class="hljs-string">'zod'</span>
  <span class="hljs-keyword">import</span> { getAndValidateRequestData } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>
  <span class="hljs-keyword">import</span> { NextResponse } <span class="hljs-keyword">from</span> <span class="hljs-string">"next/server"</span>;
  
  <span class="hljs-keyword">const</span> userSchema = z.object({
    name: z.string(),
    email: z.string().email(),
  })
  
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">POST</span>(<span class="hljs-params">req: Request</span>) </span>{
    <span class="hljs-keyword">try</span> {
      <span class="hljs-comment">/* Both data and error will be returned as possibly undefined */</span>
      <span class="hljs-keyword">const</span> { data, error } = <span class="hljs-keyword">await</span> getAndValidateRequestData(req, userSchema)
  
      <span class="hljs-keyword">if</span> (error) {
        <span class="hljs-built_in">console</span>.error(error);
        <span class="hljs-keyword">return</span> NextResponse.json({ error: error.message }, { status: <span class="hljs-number">400</span> });
      }
  
      <span class="hljs-comment">/* At this point, data will be defined,
      since we return early if an error occured. */</span>
  
      <span class="hljs-comment">/* The type of data will automatically match the Zod Schema due to TypeScript generics! */</span>
      <span class="hljs-keyword">const</span> { name, email } = data; 
      <span class="hljs-comment">/* ... */</span>
    } <span class="hljs-keyword">catch</span> (error) {
      <span class="hljs-comment">/* If a 500 error occures, we do not return the error directly back to the client,
      since it could include sensitive information from third-party APIs but rather just log it. */</span>
      <span class="hljs-built_in">console</span>.error(error)
      <span class="hljs-keyword">return</span> NextResponse.json({}, { status: <span class="hljs-number">500</span> });
    }
  }
  </code></pre>
  </div>
  <p>
    In this example, we define a Zod schema for a user, which expects an object
    with a <code>name</code> and an <code>email</code>. We then use
    <code>getAndValidateRequestData</code> to parse and validate the request
    data from our POST API route.
  </p>
  <p>
    If an error occurs, we return a 400 response with the error message. If not,
    we can proceed to use the data returned by the function in our route which
    will automatically match the type of our <code>userSchema</code>. If an
    unexpected error occurs, we log the error and return a 500 response without
    exposing any sensitive information.
  </p>
  <h2>Wrapping Up</h2>
  <p>
    This approach to request data validation in Node.js is simple, yet powerful.
    It leverages the power of Zod and TypeScript to provide a robust and
    type-safe way to validate data. I hope you find it as useful as I have in my
    projects. Happy coding!
  </p>
</div>
