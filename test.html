<div id="post-content-wrapper" class="prose css-vqpwmg">
  <h4 id="heading-do-not-rely-on-a-weather-api">
    Do not rely on a weather API
  </h4>
  <p>
    As a windsurfer, I heavily rely on weather forecast apps, and I thought it
    might be fun to build one myself. To make it more interesting, I decided not
    to use any of the many weather APIs.
  </p>
  <h4 id="heading-i-like-my-data-raw">I like my data RAW</h4>
  <p>
    I searched for ways to obtain the raw data or, at the very least, weather
    maps or arrays. During my search, I stumbled upon the website of the DWD
    (German weather service) and discovered that they provide .grib files
    containing forecast values. Since I am based in Germany, I wanted to use
    data that covers this area. Other countries have similar websites that cover
    their respective regions.
  </p>
  <h4 id="heading-how-to-obtain-these-files">How to obtain these files</h4>
  <p>
    The required files are downloadable via FTP. In my region, the ICON forecast
    model is highly accurate, so I chose to use it. The files are available at
    <a target="_blank" href="http://opendata.dwd.de">opendata.dwd.de</a>. Every
    3 hours, the forecast is updated, and new .grib files become available.
  </p>
  <p>Here's the process of getting the .grib files:</p>
  <ol>
    <li><p>Check if new .grib files are available</p></li>
    <li><p>Download the .grib files</p></li>
    <li><p>Extract the .bz2 archives to get the .grib files</p></li>
  </ol>
  <h4 id="heading-now-lets-start-coding">Now, let's start coding!</h4>
  <p>
    First, we create a new folder for the project and change the directory to
    the new folder. Then we initialize a new npm package.
  </p>
  <div>
    <pre><code>mkdir windspotter
  <span>cd</span> windspotter
  npm init -y
  </code></pre>
  </div>
  <p>
    Now, we create a <em>src</em> folder in which we'll place our
    <em>index.js</em>.
  </p>
  <div>
    <pre><code>mkdir src
  touch src/index.js
  </code></pre>
  </div>
  <p>
    The next step is to edit our <em>package.json</em>. We want to point our
    start script to the recently created <em>index.js</em>. Later, we can run
    our application with <code>npm start</code>.
  </p>
  <div>
    <pre><code class="lang-json"><span>// package.json</span>
  ...
  <span >"scripts"</span>: {
      <span >"start"</span>: <span >"node ./src/index.js"</span>
  },
  ...
  </code></pre>
  </div>
  <p>
    Let's install some npm packages we need to get the .grib files from the FTP
    server. We'll use <strong>Basic-FTP</strong> for downloading the files and
    <strong>Decompress</strong> and <strong>Decompress-bzip2</strong> for
    extracting the <em>.bz2</em> files. While other packages are available, I
    chose Basic-FTP for its simplicity and Decompress because I don't want to
    deal with streams.
  </p>
  <div>
    <pre><code>npm install basic-ftp decompress decompress-bzip2
  </code></pre>
  </div>
  <h4 id="heading-effortless-organization-for-smooth-sailing">
    Effortless Organization for Smooth Sailing!
  </h4>
  <p>
    To stay organized, we will create a few more folders and files. I prefer to
    have different tasks handled in separate modules. While it's possible to
    code everything in one file, I like to tackle the problems one step at a
    time.
  </p>
  <div>
    <pre><code>mkdir src/ftp src/config grib_data
  touch src/ftp/index.js src/config/index.js
  </code></pre>
  </div>
  <h4 id="heading-easy-maintenance">Easy Maintenance</h4>
  <p>
    We create a config file so that we have all the values that might change
    over time in one place.
  </p>
  <p>
    <strong>DataValues</strong> is an array with the measured values that we
    need for our forecast.
  </p>
  <p>
    The measured values can be displayed on different grids. We use the
    regular-lat-lon model where the grid follows the geographic coordinate
    system. This makes it easy for us to search the measured values for specific
    coordinates.
  </p>
  <p>
    The vertical level is described by <strong>FcHeight</strong>, which consists
    of 65 layers. Layer 0 is the highest, and layer 65 is closest to the ground.
    We want the values that were determined close to the ground, which is why we
    have _<em>65</em>_ here. In other forecast models, the number of layers may
    vary.
  </p>
  <div>
    <pre><code ><span>// src/config/index.js</span>
  <span>const</span> dataValues = [<span >'t'</span>, <span >'v'</span>, <span >'u'</span>];
  <span>const</span> fCModel = <span >'regular-lat-lon_model'</span>;
  <span>const</span> fCHeight = <span >'_65_'</span>;
  
  <span>module</span>.exports = {
    dataValues,
    fCModel,
    fCHeight,
  };
  </code></pre>
  </div>
  <h3 id="heading-list-download-extract-repeat">
    List, Download, Extract, Repeat
  </h3>
  <p>
    We create a new asynchronous function with the name
    <code>downloadFiles</code>. Later, we will pass the latest update time
    (databaseTimestamp) as an argument. The fallback value for databaseTimestamp
    is a timestamp with the date 0 (January 01, 1970).
  </p>
  <h4 id="heading-try-and-hopefully-never-catch">
    Try and Hopefully Never Catch
  </h4>
  <p>
    We initiate the FTP connection in a try-catch block. This way, if anything
    goes wrong, we can catch the error and continue to run the code.
  </p>
  <p>
    After connecting to the server with <code>client.access</code>, we obtain a
    list of folders for our given path. The names of these folders represent the
    update times of the forecast model.
  </p>
  <h4 id="heading-pick-the-right-time">Pick the right time</h4>
  <p>
    Now, we need to determine which folder is the most current one at runtime.
    For now, we will pass the <code>folderList</code> to a function. Later, we
    will create that function. Let's assume that we get back the name of the
    folder with the latest forecast.
  </p>
  <p>
    We change the directory to the one with the latest forecast and retrieve a
    list of files from the folder. Once again, we will pass that list to a
    function. This function will give us back the update time of those files.
  </p>
  <h4 id="heading-check-if-the-database-is-up-to-date">
    Check If the Database Is Up to Date
  </h4>
  <p>
    In the last step, we will check if the update time of the forecast is newer
    than our database update time. If the files on the server are more recent,
    we will start to download those files.
  </p>
  <h4 id="heading-look-what-we-have-so-far">Look What We Have So Far.</h4>
  <div>
    <pre><code ><span>// src/ftp/index.js</span>
  <span>const</span> ftp = <span>require</span>(<span >'basic-ftp'</span>);
  <span>const</span> { dataValues, fCModel, fCHeight } = <span>require</span>(<span >'../config'</span>);
  
  ...
  
  const downloadFiles = <span>async</span> (databaseTimestamp = <span>new</span> <span>Date</span>(<span >0</span>)) =&gt; {
    <span>const</span> server = <span >'opendata.dwd.de'</span>;
    <span>const</span> dict = <span >'weather/nwp/icon-d2/grib'</span>;
    <span>const</span> client = <span>new</span> ftp.Client();
  
    <span>try</span> {
      <span>await</span> client.access({
        <span >host</span>: server,
      });
      <span>// get a list of folders from the given ftp path</span>
      <span>const</span> dirList = <span>await</span> client.list(dict);
      <span>const</span> forecastTimes = dirList.map(<span >(<span >folderInfo</span>) =&gt;</span> folderInfo.name);
      <span>// get the latest forecast folder name</span>
      <span>const</span> nextForecastTime = getNextForecastTime(forecastTimes);
      <span>await</span> client.cd(<span >`<span >${dict}</span>/<span >${nextForecastTime}</span>`</span>);
      <span>const</span> fileList = <span>await</span> client.list();
      <span>// get the last update time from the requested files</span>
      <span>const</span> serverTimestamp = getServerTimestamp(fileList);
      <span>// check if the files are older than the data in our database</span>
      <span>if</span> (
        serverTimestamp.get &lt; databaseTimestamp ||
        <span>new</span> <span>Date</span>() - serverTimestamp &lt; <span >5</span> * <span >60</span> * <span >1000</span>
      ) {
        <span>console</span>.log(<span >'database is up to date'</span>);
        client.close();
        <span>return</span> <span class="hljs-literal">false</span>;
      }
      <span>// create a list of the files und download them</span>
  
      ...
  
      client.close();
      <span>return</span> nextForecastTime; 
    } <span>catch</span> (err) {
      <span>console</span>.log(err);
      <span>return</span> <span class="hljs-literal">false</span>;
    }
  };
  </code></pre>
  </div>
  <h4 id="heading-what-happens-in-the-blackbox">
    <a
      class="permalink-heading-button"
      title="Permalink"
      href="#heading-what-happens-in-the-blackbox"
      data-clipboard-text="https://stonehagen.hashnode.dev/embracing-grib-files-and-freeing-ourselves-from-weather-apis#heading-what-happens-in-the-blackbox"
      style="height: 32px"
      ><span class="css-eivff4">Permalink</span
      ><svg class="css-oyi044" viewBox="0 0 512 512">
        <path
          d="M301.148 394.702l-79.2 79.19c-50.778 50.799-133.037 50.824-183.84 0-50.799-50.778-50.824-133.037 0-183.84l79.19-79.2a132.833 132.833 0 013.532-3.403c7.55-7.005 19.795-2.004 20.208 8.286.193 4.807.598 9.607 1.216 14.384.481 3.717-.746 7.447-3.397 10.096-16.48 16.469-75.142 75.128-75.3 75.286-36.738 36.759-36.731 96.188 0 132.94 36.759 36.738 96.188 36.731 132.94 0l79.2-79.2.36-.36c36.301-36.672 36.14-96.07-.37-132.58-8.214-8.214-17.577-14.58-27.585-19.109-4.566-2.066-7.426-6.667-7.134-11.67a62.197 62.197 0 012.826-15.259c2.103-6.601 9.531-9.961 15.919-7.28 15.073 6.324 29.187 15.62 41.435 27.868 50.688 50.689 50.679 133.17 0 183.851zm-90.296-93.554c12.248 12.248 26.362 21.544 41.435 27.868 6.388 2.68 13.816-.68 15.919-7.28a62.197 62.197 0 002.826-15.259c.292-5.003-2.569-9.604-7.134-11.67-10.008-4.528-19.371-10.894-27.585-19.109-36.51-36.51-36.671-95.908-.37-132.58l.36-.36 79.2-79.2c36.752-36.731 96.181-36.738 132.94 0 36.731 36.752 36.738 96.181 0 132.94-.157.157-58.819 58.817-75.3 75.286-2.651 2.65-3.878 6.379-3.397 10.096a163.156 163.156 0 011.216 14.384c.413 10.291 12.659 15.291 20.208 8.286a131.324 131.324 0 003.532-3.403l79.19-79.2c50.824-50.803 50.799-133.062 0-183.84-50.802-50.824-133.062-50.799-183.84 0l-79.2 79.19c-50.679 50.682-50.688 133.163 0 183.851z"
        ></path></svg></a
    >What Happens in the Blackbox?
  </h4>
  <p>
    Let's write our <code>getNextForecastTime()</code> function. The purpose of
    this function is to find the update hour that is the least in the past.
  </p>
  <p>
    First, we need to convert our Array of Strings to an Array of Numbers. Next,
    we get the current hour when the code is executed. I have to work in UTC +0
    because the DWD Forecast is also in UTC +0.
  </p>
  <p>
    The next step is to filter the Array and remove all values that are higher
    than our current hour. Using <code>Math.max()</code>, we get the highest
    value of the resulting array.
  </p>
  <p>We convert the number to a string with a leading '0' and return it.</p>
  <div>
    <pre><code ><span>// src/ftp/index.js</span>
  ...
  const getNextForecastTime = <span >(<span >forecastTimes</span>) =&gt;</span> {
    <span>// convert Strings into Numbers</span>
    <span>const</span> forecastTimesNumbers = forecastTimes.map(<span >(<span >hour</span>) =&gt;</span> <span>parseInt</span>(hour, <span >10</span>));
    <span>// get the hour of the current time</span>
    <span>const</span> hourNow = <span>new</span> <span>Date</span>().getUTCHours();
    <span>// get the latest forcastTime to hour current time</span>
    <span>const</span> nextForecastTime = <span>Math</span>.max(
      ...forecastTimesNumbers.filter(<span >(<span >hour</span>) =&gt;</span> hour &lt;= hourNow),
    );
    <span>// return the number as string with leading zeros</span>
    <span>return</span> <span>String</span>(nextForecastTime).padStart(<span >2</span>, <span >'0'</span>);
  };
  ...
  </code></pre>
  </div>
  <h4 id="heading-are-we-up-to-date">Are We Up to Date?</h4>
  <p>
    In the <code>getFileTimestamps()</code> function, we will return the times
    when the files have been updated.
  </p>
  <p>
    We have to convert the <code>modifiedAt</code> string of the file to a
    timestamp. The special thing here is that there is no year in that
    timestamp. To fix this problem, we will take the current year from
    <code>new Date()</code>.
  </p>
  <p>
    However, taking the current year poses a corner case. On January 01 in each
    year, it is possible that we want to get the files from December 31 in the
    previous year. By setting the current year, we will produce a timestamp in
    the future. To prevent this behaviour, we will check if the server timestamp
    is newer than the current date. If so, we will subtract one year from the
    timestamp.
  </p>
  <p>
    After mapping the generated timestamps into the array, we will return the
    new array.
  </p>
  <div>
    <pre><code ><span>// src/ftp/index.js</span>
  ...
  const getFileTimestamps = <span >(<span >files</span>) =&gt;</span> {
    <span>const</span> dateNow = <span>new</span> <span>Date</span>();
    <span>return</span> files.map(<span >(<span >file</span>) =&gt;</span> {
      <span>// split the date Sting and create a timestamp from it</span>
      <span>const</span> modDateArr = file.rawModifiedAt.split(<span >' '</span>);
      <span>const</span> timestamp = <span>new</span> <span>Date</span>(
        <span >`<span >${modDateArr[<span >0</span>]}</span> <span >${modDateArr[<span >1</span>]}</span>, <span >${dateNow.getFullYear()}</span> <span >${
          modDateArr[<span >2</span>]
        }</span>+00:00`</span>,
      );
      <span>// Jan 01 cornercase</span>
      <span>if</span> (timestamp &gt; dateNow) {
        timestamp.setFullYear(timestamp.getFullYear() - <span >1</span>);
      }
      <span>return</span> timestamp;
    });
  };
  ...
  </code></pre>
  </div>
  <h4 id="heading-finally-our-loop">Finally, Our Loop:</h4>
  <p>
    Now that we have created all the necessary functions and variables, we can
    start to download the files. We loop over our array of
    <code>dataValues</code> and change the directory to the present value. We
    will generate a list of all files in this directory and filter out the
    required files by their names.
  </p>
  <p>
    Finally, we also loop over these filenames and start downloading file by
    file. Right after the download of one file is finished, we will decompress
    these files before moving to the next one. The decompression is done by the
    <code>decompressFile()</code> function. We pass in the file name and the
    directory of the file, and the function will do its magic.
  </p>
  <div>
    <pre><code ><span>// src/ftp/index.js</span>
  ...
  <span>// create a list of the files und download them</span>
      <span>for</span> (<span>const</span> value <span>of</span> dataValues) {
        <span>let</span> clientList = <span>await</span> client.list(<span >`./<span >${value}</span>`</span>);
        <span>// filter out the unwanted files</span>
        clientList = clientList
          .map(<span >(<span >file</span>) =&gt;</span> file.name)
          .filter(<span >(<span >name</span>) =&gt;</span> name.includes(fCModel) &amp;&amp; name.includes(fCHeight));
        <span>// download file per file</span>
        <span>for</span> (<span>const</span> file <span>of</span> clientList) {
          <span>await</span> client.downloadTo(<span >`./grib_data/<span >${file}</span>`</span>, <span >`./<span >${value}</span>/<span >${file}</span>`</span>);
          <span>await</span> decompressFile(file, <span >'./grib_data/'</span>);
        }
      }
  ...
  </code></pre>
  </div>
  <h4 id="heading-decompress-the-bz2">Decompress the .bz2</h4>
  <p>
    In the asynchronous function <code>decompressFile()</code>, the filenames
    and the path will be concatenated and passed into the
    <code>decompress</code> method from the <code>decompress</code> module. As a
    plugin, we specify the <code>decompressBzip2</code> module.
  </p>
  <p>
    After decompressing, we delete the source .bz2 file, and we are done with
    the magic.
  </p>
  <div>
    <pre><code ><span>// src/ftp/index.js</span>
  ...
  const fs = <span>require</span>(<span >'fs'</span>);
  <span>const</span> decompress = <span>require</span>(<span >'decompress'</span>);
  <span>const</span> decompressBzip2 = <span>require</span>(<span >'decompress-bzip2'</span>);
  ...
  const decompressFile = <span>async</span> (file, path) =&gt; {
    <span>const</span> regex = <span >/.*(?=.bz2)/</span>;
    <span>await</span> decompress(<span >`<span >${path}</span>/<span >${file}</span>`</span>, <span >'./'</span>, {
      <span >plugins</span>: [
        decompressBzip2({
          <span >path</span>: <span >`<span >${path}</span>/<span >${file.match(regex)[<span >0</span>]}</span>`</span>,
        }),
      ],
    });
    <span>await</span> fs.unlinkSync(<span >`<span >${path}</span>/<span >${file}</span>`</span>);
    fs.chmodSync(<span >`<span >${path}</span>/<span >${file.match(regex)[<span >0</span>]}</span>`</span>, <span >0o755</span>);
  };
  ...
  </code></pre>
  </div>
  <h4 id="heading-conclusion">Conclusion</h4>
  <p>
    In this blog post, I shared the first part of my journey in building a
    weather forecast app, without relying on weather APIs. Instead, I utilized
    free .grib files from the DWD (German weather service) through FTP.
  </p>
  <p>
    By leveraging the raw data provided by .grib files, I started creating a
    weather forecasting App. With the help of npm packages like Basic-FTP and
    Decompress, I managed to download and decompress the desired .grib files.
  </p>
  <p>
    At this stage, the weather app has completed the crucial step of downloading
    the forecast files. However, we are only getting started. In the upcoming
    parts of this series, we will delve into processing the downloaded .grib
    files, converting them to JSON, and storing the essential forecast
    information in MongoDB. With each of these developments, we come a step
    closer to achieving a fully functional weather forecast app.
  </p>
  <p>
    Stay tuned for the next part of the series as we continue to build our
    weather forecast app! Your comments and feedback are most welcome as I
    embark on this exciting endeavour to learn and grow.
  </p>
  <h4 id="heading-the-code">THE CODE:</h4>
  <div>
    <pre><code ><span>// src/ftp/index.js</span>
  <span>const</span> fs = <span>require</span>(<span >'fs'</span>);
  <span>const</span> ftp = <span>require</span>(<span >'basic-ftp'</span>);
  <span>const</span> decompress = <span>require</span>(<span >'decompress'</span>);
  <span>const</span> decompressBzip2 = <span>require</span>(<span >'decompress-bzip2'</span>);
  
  <span>const</span> { dataValues, fCModel, fCHeight } = <span>require</span>(<span >'../config'</span>);
  
  <span>const</span> getNextForecastTime = <span >(<span >forecastTimes</span>) =&gt;</span> {
    <span>// convert Strings into Numbers</span>
    <span>const</span> forecastTimesNumbers = forecastTimes.map(<span >(<span >hour</span>) =&gt;</span> <span>parseInt</span>(hour, <span >10</span>));
    <span>// get the hour of the current time</span>
    <span>const</span> hourNow = <span>new</span> <span>Date</span>().getUTCHours();
    <span>// get the latest forcastTime to hour current time</span>
    <span>const</span> nextForecastTime = <span>Math</span>.max(
      ...forecastTimesNumbers.filter(<span >(<span >hour</span>) =&gt;</span> hour &lt;= hourNow),
    );
    <span>// return the number as string with leading zeros</span>
    <span>return</span> <span>String</span>(nextForecastTime).padStart(<span >2</span>, <span >'0'</span>);
  };
  
  <span>const</span> getFileTimestamps = <span >(<span >files</span>) =&gt;</span> {
    <span>const</span> dateNow = <span>new</span> <span>Date</span>();
    <span>return</span> files.map(<span >(<span >file</span>) =&gt;</span> {
      <span>// split the date Sting and create a timestamp from it</span>
      <span>const</span> modDateArr = file.rawModifiedAt.split(<span >' '</span>);
      <span>const</span> timestamp = <span>new</span> <span>Date</span>(
        <span >`<span >${modDateArr[<span >0</span>]}</span> <span >${modDateArr[<span >1</span>]}</span>, <span >${dateNow.getFullYear()}</span> <span >${
          modDateArr[<span >2</span>]
        }</span>+00:00`</span>,
      );
      <span>// Jan 01 cornercase</span>
      <span>if</span> (timestamp &gt; dateNow) {
        timestamp.setFullYear(timestamp.getFullYear() - <span >1</span>);
      }
      <span>return</span> timestamp;
    });
  };
  
  <span>const</span> decompressFile = <span>async</span> (file, path) =&gt; {
    <span>const</span> regex = <span >/.*(?=.bz2)/</span>;
    <span>await</span> decompress(<span >`<span >${path}</span>/<span >${file}</span>`</span>, <span >'./'</span>, {
      <span >plugins</span>: [
        decompressBzip2({
          <span >path</span>: <span >`<span >${path}</span>/<span >${file.match(regex)[<span >0</span>]}</span>`</span>,
        }),
      ],
    });
    <span>await</span> fs.unlinkSync(<span >`<span >${path}</span>/<span >${file}</span>`</span>);
    fs.chmodSync(<span >`<span >${path}</span>/<span >${file.match(regex)[<span >0</span>]}</span>`</span>, <span >0o755</span>);
  };
  
  <span>const</span> getServerTimestamp = <span >(<span >fileList</span>) =&gt;</span> {
    <span>// reduce array to only get the required values</span>
    <span>const</span> sortedFiles = fileList.filter(<span >(<span >file</span>) =&gt;</span> dataValues.includes(file.name));
    <span>const</span> fileTimestamps = getFileTimestamps(sortedFiles);
    <span>// return latest Timestamp from folder</span>
    <span>return</span> <span>new</span> <span>Date</span>(<span>Math</span>.max(...fileTimestamps));
  };
  
  <span>const</span> downloadFiles = <span>async</span> (databaseTimestamp = <span>new</span> <span>Date</span>(<span >0</span>)) =&gt; {
    <span>const</span> server = <span >'opendata.dwd.de'</span>;
    <span>const</span> dict = <span >'weather/nwp/icon-d2/grib'</span>;
    <span>const</span> client = <span>new</span> ftp.Client();
  
    <span>try</span> {
      <span>await</span> client.access({
        <span >host</span>: server,
      });
      <span>// get a list of folders from the given ftp path</span>
      <span>const</span> dirList = <span>await</span> client.list(dict);
      <span>// convert list of folders to list of folderNames (forecastTimes)</span>
      <span>const</span> forecastTimes = dirList.map(<span >(<span >folderInfo</span>) =&gt;</span> folderInfo.name);
      <span>// get the latest forecast folder name</span>
      <span>const</span> nextForecastTime = getNextForecastTime(forecastTimes);
      <span>await</span> client.cd(<span >`<span >${dict}</span>/<span >${nextForecastTime}</span>`</span>);
      <span>const</span> fileList = <span>await</span> client.list();
      <span>// get the last update time from the requested files</span>
      <span>const</span> serverTimestamp = getServerTimestamp(fileList);
      <span>// check if the files are older than the data in our database</span>
      <span>if</span> (
        serverTimestamp.get &lt; databaseTimestamp ||
        <span>new</span> <span>Date</span>() - serverTimestamp &lt; <span >5</span> * <span >60</span> * <span >1000</span>
      ) {
        <span>console</span>.log(<span >'database is up to date'</span>);
        client.close();
        <span>return</span> <span class="hljs-literal">null</span>;
      }
  
      <span>// create a list of the files und download them</span>
      <span>for</span> (<span>const</span> value <span>of</span> dataValues) {
        <span>let</span> clientList = <span>await</span> client.list(<span >`./<span >${value}</span>`</span>);
        <span>// filter out the unwanted files</span>
        clientList = clientList
          .map(<span >(<span >file</span>) =&gt;</span> file.name)
          .filter(<span >(<span >name</span>) =&gt;</span> name.includes(fCModel) &amp;&amp; name.includes(fCHeight));
        <span>// download file per file</span>
        <span>for</span> (<span>const</span> file <span>of</span> clientList) {
          <span>await</span> client.downloadTo(<span >`./grib_data/<span >${file}</span>`</span>, <span >`./<span >${value}</span>/<span >${file}</span>`</span>);
          <span>await</span> decompressFile(file, <span >'./grib_data/'</span>);
        }
      }
      <span>console</span>.log(<span >'download complete'</span>);
      client.close();
      <span>return</span> nextForecastTime;
    } <span>catch</span> (err) {
      <span>console</span>.log(err);
      <span>return</span> <span class="hljs-literal">false</span>;
    }
  };
  
  <span>module</span>.exports = {
    downloadFiles,
  };
  </code></pre>
  </div>
  <div>
    <pre><code ><span>// src/index.js</span>
  <span>const</span> { downloadFiles } = <span>require</span>(<span >'./ftp'</span>);
  
  downloadFiles();
  </code></pre>
  </div>
</div>
